## Codefresh On-Premises

{{ template "chart.versionBadge" . }}{{ template "chart.typeBadge" . }}{{ template "chart.appVersionBadge" . }}

## Prerequisites

- Kubernetes **1.22+**
- Helm **3.8.0+**
- PV provisioner support in the underlying infrastructure
- GCR Service Account JSON `sa.json` (provided by Codefresh, contact support@codefresh.io)
- Firebase url and secret
- Valid TLS certificates for Ingress
- When external PostgreSQL is used, `pg_cron` and `pg_partman` extensions **must be enabled** for [analytics](https://codefresh.io/docs/docs/dashboards/pipeline-analytics/#content) to work (see [example](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL_pg_cron.html#PostgreSQL_pg_cron.enable))

## Get Repo Info and Pull Chart

```console
helm repo add codefresh http://chartmuseum.codefresh.io/codefresh
helm repo update
```

## Install Chart

**Important:** only helm 3.8.0+ is supported

Edit default `values.yaml` or create empty `cf-values.yaml`

- Pass `sa.json` (as a single line) to `.Values.imageCredentials.password`

```yaml
# -- Credentials for Image Pull Secret object
imageCredentials:
  registry: gcr.io
  username: _json_key
  password: '{ "type": "service_account", "project_id": "codefresh-enterprise", "private_key_id": ... }'
```

- Specify `.Values.global.appUrl`, `.Values.global.firebaseUrl` and `.Values.global.firebaseSecret`

```yaml
global:
  # -- Application root url. Will be used in Ingress as hostname
  appUrl: onprem.mydomain.com

  # -- Firebase URL for logs streaming.
  firebaseUrl: <>
  # -- Firebase Secret.
  firebaseSecret: <>
```

- Specify `.Values.ingress.tls.cert` and `.Values.ingress.tls.key` OR `.Values.ingress.tls.existingSecret`

```yaml
ingress:
  # -- Enable the Ingress
  enabled: true
  # -- Set the ingressClass that is used for the ingress.
  # Default `nginx-codefresh` is created from `ingress-nginx` controller subchart
  ingressClassName: nginx-codefresh
  tls:
    # -- Enable TLS
    enabled: true
    # -- Default secret name to be created with provided `cert` and `key` below
    secretName: "star.codefresh.io"
    # -- Certificate (base64 encoded)
    cert: ""
    # -- Private key (base64 encoded)
    key: ""
    # -- Existing `kubernetes.io/tls` type secret with TLS certificates (keys: `tls.crt`, `tls.key`)
    existingSecret: ""
```

**Important:** use `cf` as Release Name at the moment

- Install the chart

```console
helm upgrade --install cf codefresh/codefresh \
    -f cf-values.yaml \
    --namespace codefresh \
    --create-namespace \
    --debug \
    --wait \
    --timeout 15m
```

## Helm Chart Configuration

See [Customizing the Chart Before Installing](https://helm.sh/docs/intro/using_helm/#customizing-the-chart-before-installing). To see all configurable options with detailed comments, visit the chart's [values.yaml](./values.yaml), or run these configuration commands:

```console
helm show values codefresh/codefresh
```

### Configuring external services for databases/message brokers/data stores

The chart contains required dependencies for the corresponding services
- [bitnami/mongodb](https://github.com/bitnami/charts/tree/main/bitnami/mongodb)
- [bitnami/postgresql](https://github.com/bitnami/charts/tree/main/bitnami/postgresql)
- [bitnami/redis](https://github.com/bitnami/charts/tree/main/bitnami/redis)
- [bitnami/rabbitmq](https://github.com/bitnami/charts/tree/main/bitnami/rabbitmq)

However, you might need to use external services like [MongoDB Atlas Database](https://www.mongodb.com/atlas/database) or [Amazon RDS for PostgreSQL](https://aws.amazon.com/rds/postgresql/). In order to use them, adjust the values accordingly:

#### External MongoDB

**Important:** Recommended version of Mongo is 4.4.x

```yaml
seed:
  mongoSeedJob:
    # -- Enable mongo seed job. Seeds the required data (default idp/user/account), creates cfuser and required databases.
    enabled: true
    # -- Root user (required ONLY for seed job!)
    mongodbRootUser: root
    # -- Root password (required ONLY for seed job!).
    mongodbRootPassword: password


global:
  # -- MongoDB connection string. Will be used by ALL services to communicate with MongoDB.
  # Ref: https://www.mongodb.com/docs/manual/reference/connection-string/
  # Note! `defaultauthdb` is omitted here on purpose (i.e. mongodb://.../[defaultauthdb]).
  # Mongo seed job will create and add `cfuser` (username and password are taken from `.Values.global.mongoURI`) with "ReadWrite" permissions to all of the required databases
  mongoURI: mongodb://cfuser:password@my-mongodb.prod.svc.cluster.local/
  # -- Should be the same as mongoURI above
  runtimeMongoURI: mongodb://cfuser:password@my-mongodb.prod.svc.cluster.local/

mongodb:
  # -- Disable mongodb subchart installation
  enabled: false
```

#### External MongoDB with MTLS

In order to use MTLS (Mutual TLS) for MongoDB, you need:

* Create a K8S secret that contains the certificate (certificate file and private key).
  The K8S secret should have one `ca.pem` key.
```console
cat cert.crt > ca.pem
cat cert.key >> ca.pem
kubectl create secret generic my-mongodb-tls --from-file=ca.pem
```

  Or you can create certificate using templates provided in Codefresh Helm chart.
  Add `.Values.secrets` into `values.yaml` as follows.
```yaml
secrets:
  mongodb-tls:
    enabled: true
    data:
      ca.pem: <base64 encoded sting>
```

*  Add `.Values.global.volumes` and `.Values.global.container.volumeMounts` to mount the secret into all the services.
```yaml
global:
  volumes:
    mongodb-tls:
      enabled: true
      type: secret
      # Existing secret with TLS certificates (key: `ca.pem`)
      # existingName: my-mongodb-tls
      optional: true

  container:
    volumeMounts:
      mongodb-tls:
        path:
        - mountPath: /etc/ssl/mongodb/ca.pem
          subPath: ca.pem

  env:
    MTLS_CERT_PATH: /etc/ssl/mongodb/ca.pem
    RUNTIME_MONGO_TLS: "true"
    # Set these var to 'false' if self-signed certificate is used to avoid x509 errors
    RUNTIME_MONGO_TLS_VALIDATE: "false"
    MONGO_MTLS_VALIDATE: "false"
```

#### External PostgresSQL

**Important:** Recommended version of Postgres is 13.x

```yaml
seed:
  postgresSeedJob:
    # -- Enable postgres seed job. Creates required user and databases.
    enabled: true
    # -- (optional) "postgres" admin user (required ONLY for seed job!)
    # Must be a privileged user allowed to create databases and grant roles.
    # If omitted, username and password from `.Values.global.postgresUser/postgresPassword` will be taken.
    postgresUser: postgres
    # -- (optional) Password for "postgres" admin user (required ONLY for seed job!)
    postgresPassword: password

global:
  # -- Postgresql hostname
  postgresHostname: my-postgres.domain.us-east-1.rds.amazonaws.com
  # -- Postgresql user
  postgresUser: cf_user
  # -- Postgresql password
  postgresPassword: password
  # -- (optional) Postgresql server port
  postgresPort: 5432

postgresql:
  # -- Disable postgresql subchart installation
  enabled: false
```

#### External Redis

**Important:** Recommended version of Redis is 7.x

```yaml
global:
  # -- Redis hostname
  redisUrl: my-redis.namespace.svc.cluster.local
  # -- Redis password
  redisPassword: password
  # -- (optional) Redis port
  redisPort: 6379

  # Should be the same as above.
  # Required for OfflineLogging feature is turned on. (i.e. when `.Values.global.firebaseSecret` is not provided)
  runtimeRedisHost: my-redis.namespace.svc.cluster.local
  runtimeRedisPassword: password
  runtimeRedisPort: 6379
  runtimeRedisDb: 2

redis:
  # -- Disable redis subchart installation
  enabled: false

```

#### External RabbitMQ

**Important:** Recommended version of RabbitMQ is 3.x

```yaml
global:
  # -- RabbitMQ hostname
  rabbitmqHostname: my-rabbitmq.namespace.svc.cluster.local
  # -- RabbitMQ user
  rabbitmqUsername: user
  # -- RabbitMQ password
  rabbitmqPassword: password

rabbitmq:
  # -- Disable rabbitmq subchart installation
  enabled: false
```

### Configuring Ingress-NGINX

The chart deploys the [ingress-nginx](https://github.com/kubernetes/ingress-nginx/tree/main) and exposes controller behind a Service of `Type=LoadBalancer`

All installation options for `ingress-nginx` are described at [Configuration](https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx#configuration)

Relevant examples for Codefesh are below:

#### ELB with SSL Termination (Classic Load Balancer)

*certificate provided from ACM*

```yaml
ingress-nginx:
  controller:
    service:
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
        service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"
        service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: '3600'
        service.beta.kubernetes.io/aws-load-balancer-ssl-cert: < CERTIFICATE ARN >
      targetPorts:
        http: http
        https: http

# -- Ingress
ingress:
  tls:
    # -- Disable TLS
    enabled: false
```

#### NLB (Network Load Balancer)

*certificate provided as base64 string or as exisiting k8s secret*

```yaml
ingress-nginx:
  controller:
    service:
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-type: nlb
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
        service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: '3600'
        service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: 'true'

# -- Ingress
ingress:
  tls:
    # -- Enable TLS
    enabled: true
    # -- Default secret name to be created with provided `cert` and `key` below
    secretName: "star.codefresh.io"
    # -- Certificate (base64 encoded)
    cert: "LS0tLS1CRUdJTiBDRVJ...."
    # -- Private key (base64 encoded)
    key: "LS0tLS1CRUdJTiBSU0E..."
    # -- Existing `kubernetes.io/tls` type secret with TLS certificates (keys: `tls.crt`, `tls.key`)
    existingSecret: ""
```

#### ALB (Application Load Balancer)

*[Application Load Balancer](https://github.com/kubernetes-sigs/aws-load-balancer-controller/tree/main/helm/aws-load-balancer-controller) should be deployed to the cluster*

```yaml
ingress-nginx:
  # -- Disable ingress-nginx subchart installation
  enabled: false

ingress:
  # -- ALB contoller ingress class
  ingressClassName: alb
  annotations:
    alb.ingress.kubernetes.io/actions.ssl-redirect: '{"Type": "redirect", "RedirectConfig":{ "Protocol": "HTTPS", "Port": "443", "StatusCode": "HTTP_301"}}'
    alb.ingress.kubernetes.io/backend-protocol: HTTP
    alb.ingress.kubernetes.io/certificate-arn: <ARN>
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS":443}]'
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/success-codes: 200,404
    alb.ingress.kubernetes.io/target-type: ip
  services:
    # For ALB /* asterisk is required in path
    cfapi:
      - /api/*
      - /ws/*
```

### Configuration with Private Registry

If you install/upgrade Codefresh on an air-gapped environment without access to public registries (i.e. `quay.io`/`docker.io`) or Codefresh Enterprise registry at `gcr.io`, you will have to mirror the images to your organization’s container registry.

- Obtain [image list](https://github.com/codefresh-io/onprem-images/tree/master/releases) for specific release

- [Push images](https://github.com/codefresh-io/onprem-images/blob/master/push-to-registry.sh) to private docker registry

- Specify image registry in values

```yaml
global:
  imageRegistry: myregistry.domain.com

ingress-nginx:
  controller:
    image:
      registry: myregistry.domain.com
```

There are 3 types of images, with the values above in rendered manifests images will be converted as follows:

**non-Codefresh** like:

```yaml
bitnami/mongo:4.2
k8s.gcr.io/ingress-nginx/controller:v1.2.0
postgres:13
```
converted to:
```yaml
myregistry.domain.com/bitnami/mongodb:4.2
myregistry.domain.com/ingress-nginx/controller:v1.2.0
myregistry.domain.com/postgres:13
```

Codefresh **public** images like:
```yaml
quay.io/codefresh/dind:20.10.13-1.25.2
quay.io/codefresh/engine:1.147.8
quay.io/codefresh/cf-docker-builder:1.1.14
```
converted to:
```yaml
myregistry.domain.com/codefresh/dind:20.10.13-1.25.2
myregistry.domain.com/codefresh/engine:1.147.8
myregistry.domain.com/codefresh/cf-docker-builder:1.1.14
```

Codefresh **private** images like:
```yaml
gcr.io/codefresh-enterprise/codefresh/cf-api:21.153.6
gcr.io/codefresh-enterprise/codefresh/cf-ui:14.69.38
gcr.io/codefresh-enterprise/codefresh/pipeline-manager:3.121.7
```
converted to:

```yaml
myregistry.domain.com/codefresh/cf-api:21.153.6
myregistry.domain.com/codefresh/cf-ui:14.69.38
myregistry.domain.com/codefresh/pipeline-manager:3.121.7
```

### Multi-role cf-api

The chart installs cf-api as a single deployment. Though, at a larger scale, we do recommend to split cf-api to multiple roles (one deployment per role) as follows:

```yaml

global:
  # -- Change internal cfapi service address
  cfapiService: cfapi-internal
  # -- Change endpoints cfapi service address
  cfapiEndpointsService: cfapi-endpoints

cfapi:
  # -- Disable default cfapi deployment
  enabled: false
  # -- (optional) Enable the autoscaler
  # The value will be merged into each cfapi role. So you can specify it once.
  hpa:
    enabled: true
# Enable cf-api roles
cfapi-internal:
  enabled: true
cfapi-ws:
  enabled: true
cfapi-admin:
  enabled: true
cfapi-endpoints:
  enabled: true
cfapi-terminators:
  enabled: true
cfapi-sso-group-synchronizer:
  enabled: true
cfapi-buildmanager:
  enabled: true
cfapi-cacheevictmanager:
  enabled: true
cfapi-eventsmanagersubscriptions:
  enabled: true
cfapi-kubernetesresourcemonitor:
  enabled: true
cfapi-environments:
  enabled: true
cfapi-gitops-resource-receiver:
  enabled: true
cfapi-downloadlogmanager:
  enabled: true
cfapi-teams:
  enabled: true
cfapi-kubernetes-endpoints:
  enabled: true
cfapi-test-reporting:
  enabled: true

# Change ingress paths
ingress:
  services:
    cfapi-endpoints:
      - /api/
    cfapi-downloadlogmanager:
      - /api/progress/download
      - /api/public/progress/download
    cfapi-admin:
      - /api/admin/
    cfapi-ws:
      - /ws
    cfapi-teams:
      - /api/team
    cfapi-kubernetes-endpoints:
      - /api/kubernetes
    cfapi-test-reporting:
      - /api/testReporting
    cfapi-kubernetesresourcemonitor:
      - /api/k8s-monitor/
    cfapi-environments:
      - /api/environments-v2/argo/events
    cfapi-gitops-resource-receiver:
      - /api/gitops/resources
      - /api/gitops/rollout
```

### High Availability

The chart installs the non-HA version of Codefresh by default. If you want to run Codefresh in HA mode, use the example values below.

```yaml
cfapi:
  hpa:
    enabed: true
    # These are the defaults for all Codefresh subcharts
    # minReplicas: 2
    # maxReplicas: 10
    # targetCPUUtilizationPercentage: 70

argo-platform:
  abac:
    hpa:
      enabled: true

  analytics-reporter:
    hpa:
      enabled: true

  api-events:
    hpa:
      enabled: true

  api-graphql:
    hpa:
      enabled: true

  audit:
    hpa:
      enabled: true

  cron-executor:
    hpa:
      enabled: true

  event-handler:
    hpa:
      enabled: true

  ui:
    hpa:
      enabled: true

cfui:
  hpa:
    enabled: true

internal-gateway:
  hpa:
    enabled: true

charts-manager:
  hpa:
    enabled: true

cluster-providers:
  hpa:
    enabled: true

context-manager:
  hpa:
    enabled: true

gitops-dashboard-manager:
  hpa:
    enabled: true

helm-repo-manager:
  hpa:
    enabled: true

k8s-monitor:
  hpa:
    enabled: true

kube-integration:
  hpa:
    enabled: true

pipeline-manager:
  hpa:
    enabled: true

runtime-environment-manager:
  hpa:
    enabled: true

tasker-kubernetes:
  hpa:
    enabled: true

```

## Migrating from 1.4.x onprem to 2.0.0

This major chart version change (v1.4.X -> v2.0.0) contains some **incompatible breaking change needing manual actions**.

**Before applying the upgrade, read through this section!**

### ⚠️ [Kcfi](https://github.com/codefresh-io/kcfi) Deprecation Notice

This major release deprecates [kcfi](https://github.com/codefresh-io/kcfi) installer. The recommended way to install Codefresh On-Prem is **Helm**.
Due to that, Kcfi `config.yaml` will not be compatible for Helm-based installation.
You still can reuse the same `config.yaml` for the Helm chart, but you need to remove (or update) the following sections.

* `.Values.metadata` is deprecated. Remove it from `config.yaml`

*1.4.x `config.yaml`*
```yaml
metadata:
  kind: codefresh
  installer:
    type: helm
    helm:
      chart: codefresh
      repoUrl: http://chartmuseum.codefresh.io/codefresh
      version: 1.4.x
```

* `.Values.kubernetes` is deprecated. Remove it from `config.yaml`

*1.4.x `config.yaml`*
```yaml
kubernetes:
  namespace: codefresh
  context: context-name
```

* `.Values.tls` (`.Values.webTLS`) is moved under `.Values.ingress.tls`. Remove `.Values.tls` from `config.yaml` afterwards.

  See full [values.yaml](./values.yaml#L92).

*1.4.x `config.yaml`*
```yaml
tls:
  selfSigned: false
  cert: certs/certificate.crt
  key: certs/private.key
```

*2.0.0 `config.yaml`*
```yaml
# -- Ingress
ingress:
  # -- Enable the Ingress
  enabled: true
  # -- Set the ingressClass that is used for the ingress.
  ingressClassName: nginx-codefresh
  tls:
    # -- Enable TLS
    enabled: true
    # -- Default secret name to be created with provided `cert` and `key` below
    secretName: "star.codefresh.io"
    # -- Certificate (base64 encoded)
    cert: "LS0tLS1CRUdJTiBDRVJ...."
    # -- Private key (base64 encoded)
    key: "LS0tLS1CRUdJTiBSU0E..."
    # -- Existing `kubernetes.io/tls` type secret with TLS certificates (keys: `tls.crt`, `tls.key`)
    existingSecret: ""
```

* `.Values.images` is deprecated.  Remove `.Values.images` from `config.yaml`.

  - `.Values.images.codefreshRegistrySa` is changed to `.Values.imageCredentials`

  - `.Values.privateRegistry.address` is changed to `.Values.global.imageRegistry` (no trailing slash `/` at the end)

  See full `values.yaml` [here](./values.yaml#L2) and [here](./values.yaml#L143).

*1.4.x `config.yaml`*
```yaml
images:
  codefreshRegistrySa: sa.json
  usePrivateRegistry: true
  privateRegistry:
    address: myprivateregistry.domain
    username: username
    password: password
```

*2.0.0 `config.yaml`*
```yaml
# -- Credentials for Image Pull Secret object
imageCredentials: {}
# Pass sa.json (as a single line). Obtain GCR Service Account JSON (sa.json) at support@codefresh.io
# E.g.:
# imageCredentials:
#   registry: gcr.io
#   username: _json_key
#   password: '{ "type": "service_account", "project_id": "codefresh-enterprise", "private_key_id": ... }'
```

*2.0.0 `config.yaml`*
```yaml
global:
  # -- Global Docker image registry
  imageRegistry: "myprivateregistry.domain"
```

* `.Values.dbinfra` is deprecated. Remove it from `config.yaml`

*1.4.x `config.yaml`*
```yaml
dbinfra:
  enabled: false
```

* `.Values.firebaseUrl` and `.Values.firebaseSecret` is moved under `.Values.global`

*1.4.x `config.yaml`*
```yaml
firebaseUrl: <url>
firebaseSecret: <secret>
newrelicLicenseKey: <key>
```

*2.0.0 `config.yaml`*
```yaml
global:
  # -- Firebase URL for logs streaming.
  firebaseUrl: ""
  # -- Firebase Secret.
  firebaseSecret: ""
  # -- New Relic Key
  newrelicLicenseKey: ""
```

* `.Values.global.certsJobs` and `.Values.global.seedJobs` is deprecated. Use `.Values.seed.mongoSeedJob` and `.Values.seed.postgresSeedJob`.

  See full [values.yaml](./values.yaml#L42).

*1.4.x `config.yaml`*
```yaml
global:
  certsJobs: true
  seedJobs: true
```

*2.0.0 `config.yaml`*
```yaml
seed:
  # -- Enable all seed jobs
  enabled: true
  # -- Mongo Seed Job. Required at first install. Seeds the required data (default idp/user/account), creates cfuser and required databases.
  # @default -- See below
  mongoSeedJob:
    enabled: true
  # -- Postgres Seed Job. Required at first install. Creates required user and databases.
  # @default -- See below
  postgresSeedJob:
    enabled: true
```

### ⚠️ Migration to [Library Charts](https://helm.sh/docs/topics/library_charts/) Notice

All Codefresh subcharts templates (i.e. `cfapi`, `cfui`, `pipeline-manager`, `context-manager`, etc) has been migrated to use helm [library charts](https://helm.sh/docs/topics/library_charts/).
That allows to unify values structure across all Codefresh owned charts. However, there are some **immutable** fields in the old charts which cannot be upgraded during a regular `helm upgrade`, thus additional manual actions are required.

Run the following commands before appying the upgrade.

* Delete `cf-runner` and `cf-builder` stateful sets.

```console
kubectl delete sts cf-runner --namespace $NAMESPACE
kubectl delete sts cf-builder --namespace $NAMESPACE
```

* Delete all jobs

```console
kubectl delete job --namespace $NAMESPACE -l release=cf
```

* In `values.yaml`/`config.yaml` remove `.Values.nomios.ingress` section if you have it

```yaml
nomios:
  # Remove ingress section
  ingress:
    ...
```

### ⚠️ New Services Notice

Codefesh 2.0.0 chart includes additional dependent microservices(charts):
- `argo-platform`: Main Codefresh GitOps module.
- `internal-gateway`: NGINX that proxies requests to the correct components (api-graphql, api-events, ui).
- `argo-hub-platform`: Service for Argo Workflow templates.
- `platform-analytics` and `etl-starter`: Service for [Pipelines dasboard](https://codefresh.io/docs/docs/dashboards/home-dashboard/#pipelines-dashboard)

These services require two additional databases in MongoDB (`audit` and `read-models`) and in Postgresql (`analytics` and `analytics_pre_aggregations`)
The helm chart is configured to re-run seed jobs to create necessary databases and users during the upgrade.

```yaml
seed:
  # -- Enable all seed jobs
  enabled: true
```

The bare minimal workload footprint for the new services (without HPA or PDB) is `~4vCPU` and `~8Gi RAM`

{{ template "chart.valuesSection" . }}