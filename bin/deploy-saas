#!/usr/bin/env bash

set -e


readonly BASEPATH="$(dirname "$0")"
source "$BASEPATH/helpers"

usage() {
	echo "$0 [-h] [service-to-deploy] [..] [..]"
	exit 0
}

# =---
# MAIN
# =---

check kubectl
check helm
check sops

[ "$1" == "-h" ] && usage

if [ -z "$ENVIRONMENT" ]
then
    echo "Environment variable $ENVIRONMENT is not set"
		exit 1
fi

if [ -z "$CLUSTER" ]
then
    echo "Environment variable $CLUSTER is not set"
    exit 1
fi

if [ -z "$DNS" ]
then
    echo "Environment variable $DNS is not set"
    exit 1
fi

if [ -z "$NAMESPACE" ]
then
    echo "Environment variable $NAMESPACE is not set"
    exit 1
fi

echo "Found environment $ENVIRONMENT"
APP_DNS=$DNS
echo "Setting APP_DNS=$APP_DNS"

KUBE_CONTEXT=$CLUSTER
echo "Setting KUBE_CONTEXT=$KUBE_CONTEXT"

USE_LOCK=$USE_HELM_LOCK
echo "Setting USE_LOCK=$USE_LOCK"

if [ "$DRY_RUN" == "true" ]
then
	msg "Running in dry-run mode"
fi

if [ "$DYNAMIC_ENVIRONMENT" == "true" ]
then
  check aws
	if [ -z "$ENVIRONMENT" ]
	then
	  msg "ENVIRONMENT not set, generating random name"
		ENVIRONMENT=$(getRandomName)
		msg "ENVIRONMENT name: $ENVIRONMENT"
	fi
fi


msg "Available kubernetes contexts"
kubectl config get-contexts

msg "Using context $KUBE_CONTEXT and namespace $NAMESPACE"
kubectl config use-context $KUBE_CONTEXT

if [ "$USE_LOCK" == "true" ]
then
  msg "Helm lock file will be used to deploy"
else
  msg "Helm lock file will not be used to deploy"
fi

msg "Decrypting all secrets"
./sops.sh -d

msg "Init Helm"
helm init --client-only

msg "Waiting for Helm to be ready ..."
waitForHelm

sleep 3
msg "Helm version"
helm version

if [ "$USE_LOCK" == "true" ]
then
	msg "Fetching latest helm dependencies, according to requirements.yaml"
	helm dependency update codefresh
	msg "Fetching tested helm dependencies, according to requirements.lock"
	helm dependency build codefresh
else
	msg "Fetching latest helm dependencies, according to requirements.yaml"
	helm dependency update codefresh
fi
# print charts
ls -al codefresh/charts
msg "The following services are going to be deployed: "
echo "@$"

customVals=$(processCustomVals)
redeployArgs=$(genRedeployArgs $@)
customFlags=$(processCustomFlags)

if [[ -f codefresh/env/${ENVIRONMENT}/versions.yaml ]]; then
  versionsVals=" --values codefresh/env/${ENVIRONMENT}/versions.yaml "
fi


if [[ "${MAINTENANCE_MODE}" == "true" ]]; then
   maintenanceVals=" --values codefresh/maintenanceValues.yaml "
fi

msg "Deploying helm package"
helmCmd=$(cat <<END
helm upgrade ${ENVIRONMENT} codefresh \
	--install \
	$customFlags \
	--force \
	--reset-values \
	--namespace ${NAMESPACE} \
	--set ingress.domain="${APP_DNS}" \
	--set ingress.enabled=true \
	--set global.appUrl="${APP_DNS}" \
	--values codefresh/values.yaml \
	--values codefresh/values-dec.yaml \
	--values codefresh/regsecret-dec.yaml \
	--values codefresh/env/${ENVIRONMENT}/values-dec.yaml \
	--values codefresh/env/${ENVIRONMENT}/values.yaml \
	$versionsVals \
	$customVals \
	$redeployArgs \
	$maintenanceVals
END
)

msg "Running helm upgrade command"
echo $helmCmd
eval "$helmCmd"

msg "Status of all the services: "
kubectl get pods

if [ "$DYNAMIC_ENVIRONMENT" == "true" ]
then
	msg "Waiting for the ingress controller to receive a public ip"
	waitForIngressExternalIp "$ENVIRONMENT"
	publicIp=$(getIngressIp "$ENVIRONMENT")

	msg "The ingress public's ip is: '$publicIp', adding it to dns (route53)"
	addToRoute53 "${APP_DNS}" "$publicIp"
	msg "Your environment should be accessible soon at: ${ENVIRONMENT}.dev.codefresh.io"
fi

msg "Helm Release status"
helm status $ENVIRONMENT