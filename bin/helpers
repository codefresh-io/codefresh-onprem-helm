#!/bin/bash

# set -x

readonly DEV_HOSTEDZONE_ID=Z18GWS8XMDYRQ6

msg() { echo -e "\e[32mINFO ---> $1\e[0m"; }
err() { echo -e "\e[31mERR ---> $1\e[0m" ; exit 1; }

check() { command -v $1 >/dev/null 2>&1 || err "$1 utility is requiered!"; }

getIngressIp() {
	local namespace="$1"
	kubectl --namespace $namespace get svc ${namespace}-ingress-controller \
		-o go-template='{{index (index .status.loadBalancer.ingress 0) "ip"}}'
}

getIstioIngressgatewayIp() {
	local istioNamespace="istio-system"
	kubectl --namespace $istioNamespace get svc istio-ingressgateway \
		-o go-template='{{index (index .status.loadBalancer.ingress 0) "ip"}}'
}

# =--
# ROUTE53 Operations
# =--

changeRoute53() {
	local name="$1"
	local value="$2"
	local action="${3:-UPSERT}"
	eval aws route53 change-resource-record-sets \
	  --debug \
		--hosted-zone-id ${DEV_HOSTEDZONE_ID} \
		--change-batch "'{\"Changes\": [{\"Action\": \"$action\", \"ResourceRecordSet\": {\"Name\": \"$name\", \"Type\": \"A\", \"TTL\": 300, \"ResourceRecords\": [{\"Value\": \"$value\"} ] } } ] }'"
}

addToRoute53() { changeRoute53 "$1" "$2" "UPSERT"; }

deleteFromRoute53() { changeRoute53 "$1" "$2" "DELETE"; }

# We have the certificate for *.dev.codefresh.io in LetsEncrypt. We need to renew it every 3 months.
# The following command renew it only if it expired
renewCertificateOnlyIfExpired() {
    echo "Certificate of *.dev.codefresh.io in LetsEncrypt is valid not after Monday, 23 September 2019 at 12:01:32 Israel Daylight Time"
    echo "current date is `date +%Y%m%d`"
    now=`date +%Y%m%d`
    if [ "$now" -gt "20190923" ]
    then
        echo "Certificate has expired, we need to run the following command once to renew the certificate for another 3 months:"
        echo "certbot certonly  -n -m ronen@codefresh.io --agree-tos --reuse-key --keep-until-expiring --dns-route53 -d *.dev.codefresh.io"
    else
        echo "Certificate is still valid until 23 September 2019 at 12:01:32 Israel Daylight Time"
    fi

    #certbot certonly  -n -m ronen@codefresh.io --agree-tos --reuse-key --keep-until-expiring --dns-route53 -d *.dev.codefresh.io

}

# =--
# Git Operations
# =--

# get list of environments that should be updated because of git commit(s) 
getChangedEnvironments() {
	# get from and to commits
	local from=${1:-HEAD}
	local to=${2:-HEAD~1}

	# only 'production' environment should be affected by change in requirements.lock
	SKIP_WORD=".none"
	if [ "$ENVIRONMENT" != "production" ]; then
	  SKIP_WORD="requirements.lock"
	fi

	# get changes between commits
	# save current IFS
 	SAVEIFS=$IFS
  	# change IFS to new line. 
  	IFS=$'\n'
  	changes=($(git diff ${from} ${to} --name-only | grep -v .md | grep -v 'docs\|.gitignore\|.gitattributes\|.dockerignore' | grep -v $SKIP_WORD))
  	# restore IFS
  	IFS=$SAVEIFS

	# placeholder for environments
	envs=( "production" "staging" "load" "dynamic" "local" "on-prem" )
	result=()
	# check for specific environment change
	for e in "${envs[@]}"; do 
		if [[ " ${changes[@]} " =~ (${e}) ]]; then
			result+=("${e}")
		fi
	done
	# check if all environment changed
	if [[ " ${changes[@]} " =~ (codefresh/local-charts)|(codefresh/templates)|((codefresh/)[a-z-]+(.yaml))|(ingress/)|(nats/)|(registry/) ]]; then
		result+=("all")
	fi
	# check script or pipeline saas changes
	if [[ " ${changes[@]} " =~ (deploy-saas) ]]; then
		result+=("production")
		result+=("staging")
		result+=("load")
	fi

	result=( $(echo "${result[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ') )
	echo "${result[@]}"
}

getRandomName() {
	declare -a words=("astra" "abby" "book" "bad" "bold" "camp" "call" "crack" "doom" "dog" "drill" "elf" "enter" "fake" "full" "form" "fun" "girl" "good" "goblin" "grand" "groom" "goose" "king" "kind" "loop" "lame" "lamer" "little" "lost" "moon" "monk" "mark" "noon" "nord" "odd" "oven" "plain" "pirate" "pitty" "pool" "pasta" "pretty" "room" "rast" "rock" "sun" "toon" "ten" "tik" "tape" "wild" "ugly" "urgent" "who") 

	echo ${words[$RANDOM % ${#words[@]}]}-${words[$RANDOM % ${#words[@]}]}
}

processCustomVals() {
	local resultedArgs=""
	local vars=$(env | awk -F '=' '{print $1}' | grep "^custom")

	for var in $vars
	do
		local varName=$(echo $var | sed 's/custom_//' | sed 's/_/./g')
		local varValue=$(eval "echo \$$var")
		resultedArgs="$resultedArgs --set $varName=$varValue"
	done

	echo "$resultedArgs"
}

processCustomFlags() {
	local flags=""

	[ "$DEBUG_CHART" == "true" ] && flags="$flags --debug"
	[ "$DRY_RUN" == "true" ] && flags="$flags --dry-run"
	[ ! -z "$TIMEOUT" ] && flags="$flags --timeout $TIMEOUT"

	if [ "$WAIT" == "true" ] || [ -z "$WAIT" ]; then
		flags="$flags --wait"
	fi

	echo "$flags"
}

waitForHelm() {
	while true; do
		status=$(kubectl -nkube-system  get po -l app=helm -l name=tiller -o=go-template --template='{{  range $i, $v := .items }}{{ if eq $v.status.phase "Running" }}{{ $v.status.phase }}{{ end }}{{ end }}')

		msg "Helm status = $status"
		[ "$status" == "Running" ] && break

		msg "Sleeping 3 seconds ..."
		sleep 3

	done
}


genRedeployArgs() {
	local args=""

	for chart in $@; do
  	args="$args --set ${chart}.redeploy=true"
	done

	echo $args
}

waitForIngressExternalIp() {
	until getIngressIp "$1" >/dev/null 2>&1;
	do
		sleep 2
	done
}

waitForIstioIngressgatewayIp() {
    until getIstioIngressgatewayIp >/dev/null 2>&1;
	do
		sleep 2
	done
}

isIstioEnabled() {
  istioEnabled=`yq .global.istio.enabled codefresh/env/dynamic/values.yaml`
  if [ "$istioEnabled" == "true" ]
  then
    # 0 = true
    return 0
  else
    # 1 = false
    return 1
  fi
}