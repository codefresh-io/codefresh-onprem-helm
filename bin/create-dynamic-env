#!/usr/bin/env bash

set -e


readonly BASEPATH="$(dirname "$0")"
readonly KEY_FILE="service-account.json"
source "$BASEPATH/helpers"

usage() {
	echo "$0 [-h] namespace-name"
	exit 0
}

waitForIngressExternalIp() {
	until getIngressIp "$1" >/dev/null 2>&1;
	do
		sleep 2
	done
}

processCustomVals() {
	local resultedArgs=""
	local vars=$(env | awk -F '=' '{print $1}' | grep "^custom")

	for var in $vars
	do
		local varName=$(echo $var | sed 's/custom_//' | sed 's/_/./g')
		local varValue=$(eval "echo \$$var")
		resultedArgs="$resultedArgs --set $varName=$varValue"
	done

	echo "$resultedArgs"
}

waitForHelm() {
	while true; do
		status=$(kubectl get po -l app=helm -l name=tiller --show-all=false -o=custom-columns=STATUS:.status.phase --no-headers=true -nkube-system)

		msg "Helm status = $status"
		[ "$status" = "Running" ] && break

		msg "Sleeping 3 seconds ..."
		sleep 3

	done
}

processCustomFlags() {
	local flags=""

	[ "$DEBUG_CHART" == "true" ] && flags="$flags --debug"
	[ "$DRY_RUN" == "true" ] && flags="$flags --dry-run"
	[ ! -z "$TIMEOUT" ] && flags="$flags --timeout $TIMEOUT"
	[ ! -z "$VERSION" ] && flags="$flags --repo http://codefresh-helm-charts.s3-website-us-east-1.amazonaws.com --version ${VERSION}"

	if [ "$WAIT" == "true" ] || [ -z "$WAIT" ]; then
		flags="$flags --wait"
	fi

	echo "$flags"
}

# =---
# MAIN
# =---

check kubectl
check aws

[ "$1" == "-h" ] && usage


env=$(yq -r '.environments[] | select(.name=="dynamic")'  "map.yaml")
if [ -z "$env" ]
then
	echo "Environment $ENVIRONMENT not exist in map.yaml"
	exit 1
fi

msg "Available kubernetes contexts"
kubectl config get-contexts
KUBE_CONTEXT=$(echo $env | yq .cluster | sed s/\"//g )
namespaceName=$ENVIRONMENT
USE_LOCK="false"

echo "Using context $KUBE_CONTEXT and namespace $NAMESPACE"
kubectl config use-context $KUBE_CONTEXT

[[ -z "$AWS_ACCESS_KEY_ID" || -z "$AWS_SECRET_ACCESS_KEY" ]] && err "Please set your AWS credentials"


msg "Decrypting all secrets"
./sops.sh -d

msg "Init Helm"
helm init --client-only

msg "Waiting for Helm to be ready ..."
waitForHelm

sleep 5
msg "Helm version"
helm version

dbg=""
if [ "$DEBUG_CHART" == "true" ]
then
  msg "Helm repo list"
  helm repo list
  msg "Requirements.yaml"
  cat codefresh/requirements.yaml
  msg ""
  msg "Content of codefresh/charts"
  dbg="--debug"
fi

msg "Fetching latest helm dependencies, acording to requirements.yaml"
helm $dbg dependency update codefresh

customFlags=$(processCustomFlags)
customVals=$(processCustomVals)

if [ "$DRY_RUN" != "true" ]; then
	msg "Creating namespace $namespace"
	kubectl get namespace $namespaceName || kubectl create namespace $namespaceName && kubectl label namespace $namespaceName dynamic=true
fi

msg "Deploy the Codefresh' helm package"
helmCmd=$(cat <<END
helm upgrade $namespaceName codefresh \
	--install \
	$customFlags \
	--force \
	--reset-values \
	--recreate-pods \
	--namespace $namespaceName \
	--set ingress.domain="${namespaceName}.dev.codefresh.io" \
	--set ingress.enabled=true \
	--set global.appUrl="${namespaceName}.dev.codefresh.io" \
	--values codefresh/values.yaml \
	--values codefresh/values-dec.yaml \
	--values codefresh/regsecret-dec.yaml \
	--values codefresh/env/dynamic/values-dec.yaml \
	--values codefresh/env/dynamic/values.yaml \
	$customVals
END
)

msg "Running helm upgrade command"
echo $helmCmd
eval "$helmCmd"

if [ "$DRY_RUN" == "true" ]
then
	msg "Skip adding route to route53 when DRY_RUN"
else
	msg "Waiting for the ingress controller to receive a public ip"
	waitForIngressExternalIp "$namespaceName"
	publicIp=$(getIngressIp "$namespaceName")

	msg "The ingress public's ip is: '$publicIp', adding it to dns (route53)"
	addToRoute53 "${namespaceName}.dev.codefresh.io" "$publicIp"
	msg "Your environment should be accessible soon at: ${namespaceName}.dev.codefresh.io"
fi

if [ "$DRY_RUN" == "true" ]
then
	msg "Skip checking Helm Release status"
else
   msg "Helm Release status"
   helm status $namespaceName
fi

